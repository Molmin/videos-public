01 ShowProblem

这是一个博弈论问题
Alice 和 Bob 正在玩游戏
游戏中有三个整数 a1, a2 和 a3
Alice 和 Bob 轮流操作
Alice 先手
每次操作可以选择两个互不相同的整数 ai 和 aj 改变它们的值
设更改后的值为 ai 和 aj，满足 ai+aj=ai'+aj'
且 ai' 和 aj' 的差小于 ai 和 aj 的差时操作才是合法的
不能进行合法操作者输
问谁有必胜策略？

02 DescribeProblem

这个问题要求你把 x1, x2 和 x3 变为 x1+k, x2-k 和 x3
假设三个数按照从小到大的顺序排列
则这个操作等价于把所有数减去 x1 后的情形
所以我们只需要考虑
满足 0 小于等于 x 小于等于 y 的 (0,x,y) 情形

03 SolveByBruteForce

这里我使用了时间复杂度是立方级别的动态规划算法
暴力枚举每个 (0,x,y) 状态的下一步操作
现在我已经得到了结果

04 ReadCode

result[i][j] 表示
状态 (0,i,j) 是否是必胜的状态
下面对操作前两个数
后两个数
第一个数和第三个数三种情况
分类讨论进行枚举转移

05 ReadBruteForceResult

这是我根据程序运行的结果绘制成的图表
其中
第 0 行第 0 列是红色格子
表示 (0,0,0) 不是一个必胜的状态
再例如第 6 行第 6 列的绿色格子
则表示 (0,6,6) 是必胜状态

06 AnalysisResult

根据上面的结果可以很明显地看出
只有 (0,0,n) 和 (0,n,n) 两种情形
可能是必败的状态
而 (0,n,n) 同时减去 n
就等价于 (-n,0,0)
也就等价于 (0,0,n)
所以我们只需要考虑 (0,0,n) 的情形

07 GuessConcusions

下面我们来观察一下
满足 (0,0,n) 是必胜状态的 n 的特点
现在显示出的 12 个数都是必胜的 n
显然
它们都是偶数
把它们的素因子 2 全部提取出来
容易发现
2 的指数都是奇数
也就是说
这些 n 都可以表示成这样的形式
下面我们尝试对证明进行探索

08 ProofSameNumbersSituation

首先来看 (0,0,n)
也就是存在两数相同的情形
容易发现
(0,0,n) 的下一次操作只能对 0 和 n 进行
于是它必须变成 (n,k,n-k)
k 的取法有两种
要么 k 小于 n-k
要么 n 等于 2k
当 k 小于 n-k 时
三个数互不相同
是必胜状态
这一点我将在后面给出证明
所以我们必须选择 n 等于 2k 的情形
也就是说
我们必须把 (0,0,n) 变为 (0,n/2,n/2)
等价于 (0,0,n/2)
容易发现每次操作都少一个素因子 2
直到变为奇数时就输
所以我们的猜想成立

09 ProofDifferentNumbersSituation

别忘了我们还没有证明
三个数都不相等的时候
一定是必胜状态
这里使用了一个非常巧妙的方法
考虑反证法
如果状态 (0,x,y) 是必败状态
要导出矛盾
不妨假设 0 小于 x 小于 y
x 又小于 y 减 x
在这个状态下
我们可以对 0 和 y 操作
变成 (x,x,y-x)
由于 (0,x,y) 是必败的
所以这一定是一个必胜的状态
此时只能对 x 和 y-x 操作
即变为 (x,x+k,y-x-k)
必然存在一个 k
使得这是必败状态
再仔细观察
就会发现最初的状态也可以变换到这个状态
也就是必败态可以转移到另一个必败态
这是不可能的
所以三个数不相等的时候一定是必胜的

10 ShowConclusions

至此
我们已经完成了 2015 年罗马尼亚大师赛第二题的转化问题
至于转化这一步较为简单
想必屏幕前的朋友们都可以独自完成这一步转化
这题可以转化为
(0,0,n-3) 这一状态是否是必胜态
结论就是
当且仅当 n-3 的素因子 2 的个数是奇数时
是必胜状态
否则就是必败状态

11 ShowGymProblem

但是在这里
我还要介绍这个问题的一个扩展版本
这是一个信息学教练向某比赛提供的题目
它给出一列数 a
但不是要求你做更多个数博弈的版本
而是问你有多少种选法
选出三个数使得局面是必胜的

12 InclusionExclusion

直接计数麻烦
我们考虑容斥原理
所有情况的总数显然是 n 取 3
这非常容易
必败态分为两种
要么三数相等
直接枚举这个数
累加求和
就可以求出方案数
还算比较简单
剩下的情况就是两数相等
这时问题较为困难
我们后面讨论
而答案
就是 S 减去 S1
再减去 S2

13 SolveProblemByTrie

考虑枚举两数差中素因子 2 的个数 k
求有多少 ai 和 aj 的差包含恰好 k 个 2
其中
k 是任意一个非 0 的偶数
由于涉及素因子 2
容易想到把两数都表示成二进制
由于两数差是 2 的 k 次方的倍数
所以两数模 2 的 k 次方同余
也就是两数二进制后 k 位依次相等
而必须恰好含有 k 个 2
就要求两数二进制下一位必须不同
也就是这 k+1 个式子
这要求两数的二进制后 k 位相同
其余只有对下一位的要求
我们考虑使用 01 Trie 来解决问题
也就是在每个数的二进制中
从后往前扫描每个二进制位建出 Trie 树
每个结点记录有多少个数经过了这个结点
再次枚举每个数
扫描偶数位统计有多少数正好和它的后若干位相同
累计答案即可

14 Summary

现在
我们已经在 O(n log v) 的时间复杂度内
解决了这个问题
